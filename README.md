# WasmEdgeSDL

**WasmEdgeSDL** is a [WasmEdge](https://wasmedge.org/) plugin that exposes [SDL3](https://libsdl.org/) functions to WebAssembly guest programs. It enables SDL-based applications to run in WebAssembly environments with a seamless host-guest function bridge.

---

## Project Structure

```

CMakeLists.txt           # Builds the shared library: libwasmpluginWasmEdgeSDL.so
template/                # Contains original SDL 3.2.20 headers (can be upgraded)
shim/                    # Shim files bridging WASM guest and SDL host
guest/                   # SDL 3.2.20 headers annotated as WASM host functions (auto-generated)
shimgen.py               # Generates shim functions for all SDL functions if missing
headergen.py             # Annotates SDL functions for WASM host bindings and creates guest/include
WasmEdgeSDL_module.c     # Plugin entrypoint registering the WasmEdgeSDL module

````

---

## How It Works

1. **Header Templates (`template/`)**  
   - Contains standard SDL headers from a specific SDL version (currently 3.2.20).  
   - Serves as the source of truth for generating guest headers and host shims.

2. **Guest Headers (`guest/`)**  
   - Generated by `headergen.py`.  
   - SDL headers are annotated as WASM host functions so that guest programs can call them directly.  
   - Example:  
     ```c
     __attribute__((import_module("WasmEdgeSDL"), import_name("SDL_crc32")))
     extern SDL_DECLSPEC Uint32 SDLCALL SDL_crc32(Uint32 crc, const void *data, size_t len);
     ```

3. **Shim Files (`shim/`)**  
   - Generated by `shimgen.py`.  
   - Each SDL function gets a corresponding host-side stub exposing it to the WebAssembly guest.  
   - The stubs must be implemented manually and redirected to SDL3.
   - Central registration file `WasmEdgeSDL_shim.c` automatically binds all exported functions to the module instance.

4. **Plugin Entrypoint (`WasmEdgeSDL_module.c`)**  
   - Registers the WasmEdgeSDL module with WasmEdge, allowing guests to import SDL functions by module name `WasmEdgeSDL`.

---

## Usage

1. **Build the Plugin**

```bash
cmake -B build -DWASMEDGE_LIB_DIR=/path/to/wasmedge/lib -DWASMEDGE_INCLUDE_DIR=/path/to/wasmedge/include
cmake --build build
```

This generates `libwasmpluginWasmEdgeSDL.so`.

2. **Include in WasmEdge Environment**

* Install the plugin to `<wasmedge-path>/plugin`.
* Also set environment variable `WASMEDGE_PLUGIN_PATH` to `<wasmedge-path>/plugin`

3. **Use the plugin from the Wasm guest**

* Compile your WebAssembly project using SDL with `-I/<wasmedge-sdl-path>/guest/include` flag.
* This will bring SDL headers tweaked for WebAssembly to your scope.

---

## Development

1. **Generate Guest Headers**

```bash
python3 headergen.py
```

This will generate `guest/include` from `template/include`.
Run this file when you bump the SDL version under `template`.


2. **Generate Shim Files**

```bash
python3 shimgen.py
```

This will not touch existing shim functions, and only insert new ones that do not exist at the shim side.
Run this file when you bump the SDL version under `template`.

3. **Implementation**

If `shimgen.py` reported creating new stub functions, write the actual implementation under `shim/`.

- Under `WasmEdgeSDL_shim.c`
  - Go to `/* EXPORT WasmEdgeSDL_<funcname> */`
  - Tweak return type and arguments to match wasm32 types
- Under `WasmEdgeSDL_<file>.c`
  - Go to the definition of the new stub function
  - Replace `/* TODO: Implement */` with the actual implementation

---

## Notes

* SDL version in `template/` can be upgraded as needed; rerunning `headergen.py` and `shimgen.py` will update the guest headers and shim functions.
* Shim files can be manually edited after generation to implement host logic beyond the autogenerated stubs.
* All guest functions use `__attribute__((import_module("WasmEdgeSDL"), import_name("<func>")))` to bind automatically to their host implementations.

---

## Goals

* Provide a complete bridge for SDL to WebAssembly guests.
* Allow easy updating of SDL versions without breaking the WASM interface.
* Keep guest headers and shim functions synchronized and maintainable through automation.

